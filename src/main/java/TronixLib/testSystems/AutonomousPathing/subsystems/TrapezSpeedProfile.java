//// RobotBuilder Version: 2.0
////
//// This file was generated by RobotBuilder. It contains sections of
//// code that are automatically generated and assigned by robotbuilder.
//// These sections will be updated in the future when you export to
//// Java from RobotBuilder. Do not put any code or make any change in
//// the blocks indicating autogenerated code or it will be lost on an
//// update. Deleting the comments indicating the section will prevent
//// it from being updated in the future.
//
//
//package org.usfirst.frc3550.Mihai2018.subsystems;
//
//import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
//
//
///**
// *
// */
//public class TrapezSpeedProfile {
//     
//	public int m_CurDistance;
//	public int m_Distance;
//	public int mDistanceGoalThreshold;
//	
//    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
//	public static final double NORMALSPEED  = 0.95;  //drive for normal speed
//	public static final double SLOWSPEED    = 0.50;  //drive motor slow speed
//	public static final boolean SENSITIVITY = true; // drive motor sensibility
//
//    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
//
//    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
//    
//    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
//
//
//    // Put methods for controlling this subsystem
//    // here. Call these from Commands.
//
//    public void TrapezSpeedProfile() {
//	    m_CurDistance = 0;
//		m_Distance = 0;
//		mDistanceGoalThreshold = 10;
//		
//        m_VMax = 24;        // 24" per second
//        m_A = m_VMax / 1.0; // Rejoindre vitesse max en 1 sec
//    }
//	
//    public void SetDistance(int distance, double vmax, double a)
//	{
//		// On assume v0 = v3 = 0 pour l'instant
//		m_v0 = 0;
//		m_v3 = 0;
//		m_Distance = distance;
//		m_CurDistance = 0;
//		m_CurIteration = 0;
//		m_VMax = vmax;
//		m_A = a;
//
//		m_t1 = (m_VMax-m_v0) / m_A; // time from v0 to vmax (time to reach full speed)
//        m_t4 = (m_VMax-m_v3) / m_A;   // time from vmax to v3 (time to brake)
//        m_d1 = m_v0*m_t1 + 0.5*m_A*m_t1*m_t1; // distance t0-t1
//        m_d2 = m_v3*m_t4 + 0.5*m_A*m_t4*m_t4; // distance t2-t3
//
//		if (m_d1+m_d2 < m_Distance )
//		{
//			// plateau at vmax in the middle
//			m_tplateau = ( m_Distance - m_d1 - m_d2 ) / m_VMax;
//			m_t2 = m_t1 + m_tplateau;
//			m_t3 = m_t2 + m_t4;
//		}
//		else
//		{
//			double brake_distance = 10.0;
//			
//			// start breaking before reaching vmax
//			// http://wikipedia.org/wiki/Classical_mechanics#1-Dimensional_Kinematics
//			m_t1 = ( Math.sqrt( 2.0*m_A*brake_distance + m_v0*m_v0 ) - m_v0 ) / m_A;
//			m_t2 = m_t1;
//			m_t3 = m_t2 + ( Math.sqrt( 2.0*m_A*(m_Distance-brake_distance) + m_v3*m_v3 ) - m_v3 ) / m_A;
//		}
//	}
//    
//	public double DistanceMove() {
//		return 0.5;
//	}
//	
//	public boolean isDistanceDone() {
//		return false; //m_Distance - m_CurDistance < mDistanceGoalThreshold;  // Arrive a moins de 10mm de la destination
//	}
//	
//	public void display(){
//	 //SmartDashboard.putNumber("speedDeplacmentLeftFront", leftFrontMotor.get());
//	 //SmartDashboard.putNumber("speedDeplacmentLeftRear",leftRearMotor.get());
//	 //SmartDashboard.putNumber("speedDeplacmentRightFront", rightFrontMotor.get());
//	 //SmartDashboard.putNumber("speedDeplacmentRightRear",rightRearMotor.get());
//	 //SmartDashboard.putNumber("EncoderPosition", getPositionLeftRearMotor());
//	}
//    
//}
//
