// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3550.Julius2018;

import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.CommandGroup;
import edu.wpi.first.wpilibj.command.Scheduler;
//import edu.wpi.first.wpilibj.command.Subsystem;
//import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc3550.Julius2018.theory6.pathing.*;
import org.usfirst.frc3550.Julius2018.theory6.pathing.Paths6.FROM_RIGHT;
import org.usfirst.frc3550.Julius2018.commands.pathing.Paths.FROM_RIGHT_PORTAL;

import org.usfirst.frc3550.Julius2018.commands.*;
import org.usfirst.frc3550.Julius2018.subsystems.*;
import org.usfirst.frc3550.Julius2018.theory6.pathing.*;
import org.usfirst.frc3550.Julius2018.util.FieldMesures;
//import org.usfirst.frc3550.Robotronix2017.commands.ForwardWithEncoderTurnCommand;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in 
 * the project.
 */
public class Robot extends IterativeRobot {
	
	public static OI oi;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static DriveTrain driveTrain;
	public static PinceSubsystem pinceSubsystem;
	public static DigitalInput Cubedetect;
	public static GearsHandler gearsHandler;
	public static GrandCadreSubsystem GrandCadreSubsystem;
	public static PetitCadreSubsystem PetitCadreSubsystem;
	public static FieldMesures fieldMesures;
	public static Grimpeur grimpeur;
	public static Cameras cameras;
	private DriverStation ds = DriverStation.getInstance();
	private String gameCode;
	SendableChooser<CommandGroup> m_autoChooserLeft;
	SendableChooser<CommandGroup> m_autoChooserRight;
    
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	//
	// AUTONOMOUS VARIABLES
	//
    CommandGroup m_autonomousCommand;
//	public Command[] m_autonomousCommandArray;
//	
//	public final int AUTOCHOOSER_NB_OBJECTIVE          = 10;
//	public final int AUTOCHOOSER_NB_COLORPOSITION      = 4;
//	public final int AUTOCHOOSER_NB_POSITION           = 5;
//	public final int AUTOCHOOSER_NB_TOTAL              = AUTOCHOOSER_NB_POSITION * AUTOCHOOSER_NB_COLORPOSITION * AUTOCHOOSER_NB_OBJECTIVE;
//	
//	public final int AUTOCHOOSER_POSITION_ENCODER      = AUTOCHOOSER_NB_OBJECTIVE*AUTOCHOOSER_NB_COLORPOSITION; //Le nombre multiplier par la position pour le selecteur d'autonomous
//	public final int AUTOCHOOSER_COLORPOSITION_ENCODER = AUTOCHOOSER_NB_OBJECTIVE;  //Le nombre multiplier par la couleur pour le selecteur d'autonomous
//	public final int AUTOCHOOSER_OBJECTIVE_ENCODER     = 1; //Le nombre multiplier par l'objectif pour le selecteur d'autonomous 
//	
//    public SendableChooser<Integer> PositionRobotAuto;
//	public SendableChooser<Integer> ActionAutonome;
//	public SendableChooser<Command> CommandeBrutAuto;
//
//    public int CoteBasculeAuto;
//	public int CoteBalanceAuto;

	
    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    @Override
    public void robotInit() {
    	RobotMap.init();
    	// SmartDashboard.putData(driveTrain);
    	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    	driveTrain = new DriveTrain();
    	pinceSubsystem = new PinceSubsystem();
    	gearsHandler = new GearsHandler();
    	GrandCadreSubsystem = new GrandCadreSubsystem();
    	PetitCadreSubsystem = new PetitCadreSubsystem();
    	fieldMesures = new FieldMesures();
    	grimpeur = new Grimpeur();
    	cameras = new Cameras();
        //Cubedetect = new DigitalInput();
      //  CameraServer.getInstance().startAutomaticCapture(); Cameras until Finger Lakes

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
        oi = new OI();
        
        m_autoChooserLeft = new SendableChooser<CommandGroup>();
        
        // Dans AutonomousInit on assume qu'on est en position 4 pour demarrer ce choix plutot
        // que de se contenter d'un simple autoline. Donc meilleur choix par defaut est celui-ci...
        m_autoChooserLeft.addDefault("AutoLine", new PosXColorXObjAutolineCommand());
        
        m_autoChooserLeft.addObject("PosXColorXObjAutoline",              new PosXColorXObjAutolineCommand());
        m_autoChooserLeft.addObject("Pos1ColorLeftObjCubeBasculeCommand", new Pos1ColorLeftObjCubeBasculeCommand());
        //m_autoChooserLeft.addObject("Pos2ColorRightObjCubeBascule2",      new Pos2ColorRightObjCubeBascule2Command());
        //m_autoChooserLeft.addObject("Pos1ColorLeftObjCubeBalanceCommand",        new Pos1ColorLeftObjCubeBalanceCommand());
        //m_autoChooserLeft.addObject("Pos1ColorRightObjCubeBascule",       new Pos1ColorRightObjCubeBasculeCommand());
        m_autoChooserLeft.addObject("Pos2ColorLeftObjCubeBascule1Command",       new Pos2ColorLeftObjCubeBascule1Command());
        //m_autoChooserLeft.addObject("Pos2ColorLeftObjCubeBascule2",       new Pos2ColorLeftObjCubeBascule2Command());
        //m_autoChooserLeft.addObject("Pos2ColorRightObjCubeBascule1",      new Pos2ColorRightObjCubeBascule1Command());
        //m_autoChooserLeft.addObject("Pos2ColorRightObjCubeBascule2",      new Pos2ColorRightObjCubeBascule2Command());
        m_autoChooserLeft.addObject("Pos3ColorLeftObjCubeBasculeCommand",        new Pos3ColorLeftObjCubeBasculeCommand());
        //m_autoChooserLeft.addObject("Pos3ColorRightObjCubeBascule",       new Pos3ColorRightObjCubeBasculeCommand());
       // m_autoChooserLeft.addObject("Pos4ColorLeftObjCubeBalanceCommand",        new Pos4ColorLeftObjCubeBalanceCommand());
        m_autoChooserLeft.addObject("Pos4ColorLeftObjCubeBasculeCommad",        new Pos4ColorLeftObjCubeBasculeCommand());
        //m_autoChooserLeft.addObject("Pos4ColorRightObjCubeBalance",       new Pos4ColorRightObjCubeBalanceCommand());
        //m_autoChooserLeft.addObject("Pos4ColorRightObjCubeBascule",       new Pos4ColorRightObjCubeBasculeCommand());
        
        SmartDashboard.putData("AutoModeLeft", m_autoChooserLeft);

        
        
        m_autoChooserRight = new SendableChooser<CommandGroup>();
        
        // Dans AutonomousInit on assume qu'on est en position 4 pour demarrer ce choix plutot
        // que de se contenter d'un simple autoline. Donc meilleur choix par defaut est celui-ci...
        m_autoChooserRight.addDefault("AutoLine", new PosXColorXObjAutolineCommand());
        
        m_autoChooserRight.addObject("PosXColorXObjAutoline",              new PosXColorXObjAutolineCommand());
        //m_autoChooserRight.addObject("Pos1ColorLeftObjCubeBasculeCommand", new Pos1ColorLeftObjCubeBasculeCommand());
       // m_autoChooserRight.addObject("Pos1ColorRightObjCubeBalanceCommand",        new Pos1ColorRightObjCubeBalanceCommand());
        m_autoChooserRight.addObject("Pos1ColorRightObjCubeBasculeCommand",       new Pos1ColorRightObjCubeBasculeCommand());
        m_autoChooserRight.addObject("Pos2ColorRightObjCubeBasculeMontrealCommand",      new Pos2ColorRightObjCubeBascule2Command());
        //m_autoChooserRight.addObject("Pos2ColorLeftObjCubeBascule1",       new Pos2ColorLeftObjCubeBascule1Command());
        //m_autoChooserRight.addObject("Pos2ColorLeftObjCubeBascule2",       new Pos2ColorLeftObjCubeBascule2Command());
        m_autoChooserRight.addObject("Pos2ColorRightObjCubeBasculeFingerLakesCommand",      new Pos2ColorRightObjCubeBascule1Command());
        //m_autoChooserRight.addObject("Pos2ColorRightObjCubeBascule2",      new Pos2ColorRightObjCubeBascule2Command());
        //m_autoChooserRight.addObject("Pos3ColorLeftObjCubeBascule",        new Pos3ColorLeftObjCubeBasculeCommand());
        m_autoChooserRight.addObject("Pos3ColorRightObjCubeBasculeCommand",       new Pos3ColorRightObjCubeBasculeCommand());
        //m_autoChooserRight.addObject("Pos4ColorLeftObjCubeBalance",        new Pos4ColorLeftObjCubeBalanceCommand());
        //m_autoChooserRight.addObject("Pos4ColorLeftObjCubeBascule",        new Pos4ColorLeftObjCubeBasculeCommand());
        //m_autoChooserRight.addObject("Pos4ColorRightObjCubeBalanceCommand",       new Pos4ColorRightObjCubeBalanceCommand());
        m_autoChooserRight.addObject("Pos4ColorRightObjCubeBasculeCommand",       new Pos4ColorRightObjCubeBasculeCommand());
        
        SmartDashboard.putData("AutoModeRight", m_autoChooserRight);

		//installAutonomous();
		
        SmartDashboard.putBoolean("DetectCube", Robot.pinceSubsystem.IsCubeHere());
    }

/*	private void installAutonomous() {
		//
		// Sets the autonomous commands to be ready for use
		//
//        m_autonomousCommandArray = new Command[AUTOCHOOSER_NB_TOTAL];
//		autonomousCommandArrayInit();
		
		// > Starting position < combobox
//        PositionRobotAuto = new SendableChooser<>();
//        
//		PositionRobotAuto.addDefault("OverrideCommandeManuel", (Integer)(0 * AUTOCHOOSER_POSITION_ENCODER));
//		PositionRobotAuto.addObject ("position 1",             (Integer)(1 * AUTOCHOOSER_POSITION_ENCODER));
//		PositionRobotAuto.addObject ("position 2",             (Integer)(2 * AUTOCHOOSER_POSITION_ENCODER));
//		PositionRobotAuto.addObject ("position 3",             (Integer)(3 * AUTOCHOOSER_POSITION_ENCODER));
//		PositionRobotAuto.addObject ("position 4",             (Integer)(4 * AUTOCHOOSER_POSITION_ENCODER));
//		
//		SmartDashboard.putData("Position robot autonome", PositionRobotAuto);
//		
//		// > Objective < combobox
//		ActionAutonome = new SendableChooser<>();
//		
//		ActionAutonome.addDefault("Rien Faire",                (Integer)(0  * AUTOCHOOSER_OBJECTIVE_ENCODER));
//		ActionAutonome.addObject("AutoLine",                 (Integer)(1  * AUTOCHOOSER_OBJECTIVE_ENCODER));
//		ActionAutonome.addObject("Bascule",            (Integer)(2  * AUTOCHOOSER_OBJECTIVE_ENCODER));
//		ActionAutonome.addObject("Bascule special", (Integer)(3  * AUTOCHOOSER_OBJECTIVE_ENCODER));
//		ActionAutonome.addObject("balance",            (Integer)(4  * AUTOCHOOSER_OBJECTIVE_ENCODER));
//		//ActionAutonome.addObject("Autre action",      (Integer)(5  * AUTOCHOOSER_OBJECTIVE_ENCODER));
//		// Add if need more
//		
//		SmartDashboard.putData("Objectif autonome", ActionAutonome);
//		
//		// Auto Commands MANUAL combobox
//		CommandeBrutAuto = new SendableChooser<>();
//		
//		// **faire HYPER attention d'avoir le bon index en modifiant/rajoutant des commandes** 
//		
//		CommandeBrutAuto.addDefault("Ne fais rien",
//				                    m_autonomousCommandArray[calcID(0, 0, 1)]);
//				
//		// Auto-line (Objective #1)
//		CommandeBrutAuto.addObject ("Auto-line",
//		                            m_autonomousCommandArray[calcID(1, 0, 1)]);
//		
//		
//		//Cube dans la Bascule (Objective #2 et special #3)
//		CommandeBrutAuto.addObject ("Bascule @ bascule Gauche @ Pos 1", 
//		                            m_autonomousCommandArray[calcID(1, 0, 2)]); 
//		CommandeBrutAuto.addObject ("Bascule @ bascule Gauche @ Pos 2a", 
//		                            m_autonomousCommandArray[calcID(2, 0, 2)]);
//		CommandeBrutAuto.addObject ("Bascule @ bascule Gauche @ Pos 2b", 
//		                            m_autonomousCommandArray[calcID(2, 0, 3)]);
//		CommandeBrutAuto.addObject ("Bascule @ bascule Gauche @ Pos 3", 
//		                            m_autonomousCommandArray[calcID(3, 0, 2)]);
//		CommandeBrutAuto.addObject ("Bascule @ bascule Gauche @ Pos 4", 
//		                            m_autonomousCommandArray[calcID(4, 0, 2)]);
//									
//		CommandeBrutAuto.addObject ("Bascule @ bascule Droite @ Pos 1", 
//		                            m_autonomousCommandArray[calcID(1, 1, 2)]); 
//		CommandeBrutAuto.addObject ("Bascule @ bascule Droite @ Pos 2a", 
//		                            m_autonomousCommandArray[calcID(2, 1, 2)]);
//		CommandeBrutAuto.addObject ("Bascule @ bascule Droite @ Pos 2b", 
//		                            m_autonomousCommandArray[calcID(2, 1, 3)]);
//		CommandeBrutAuto.addObject ("Bascule @ bascule Droite @ Pos 3", 
//		                            m_autonomousCommandArray[calcID(3, 1, 2)]);
//		CommandeBrutAuto.addObject ("Bascule @ bascule Droite @ Pos 4", 
//		                            m_autonomousCommandArray[calcID(4, 1, 2)]);
//		
//		// Cube dans la Balance (Objective #4)
//		CommandeBrutAuto.addObject ("Balance @ balance Gauche @ Pos 1", 
//		                            m_autonomousCommandArray[calcID(1, 0, 4)]); 
//		CommandeBrutAuto.addObject ("Balance @ balance Gauche @ Pos 2", 
//		                            m_autonomousCommandArray[calcID(2, 0, 4)]);
//		CommandeBrutAuto.addObject ("Balance @ balance Gauche @ Pos 3", 
//		                            m_autonomousCommandArray[calcID(3, 0, 4)]);
//		CommandeBrutAuto.addObject ("Balance @ balance Gauche @ Pos 4", 
//		                            m_autonomousCommandArray[calcID(4, 0, 4)]);
//		
//		CommandeBrutAuto.addObject ("Balance @ balance Droite @ Pos 1", 
//		                            m_autonomousCommandArray[calcID(1, 2, 4)]); 
//		CommandeBrutAuto.addObject ("Balance @ balance Droite @ Pos 2", 
//		                            m_autonomousCommandArray[calcID(2, 2, 4)]);
//		CommandeBrutAuto.addObject ("balance @ balance Droite @ Pos 3", 
//		                            m_autonomousCommandArray[calcID(3, 2, 4)]);
//		CommandeBrutAuto.addObject ("balance @ balance Droite @ pos 4", 
//		                            m_autonomousCommandArray[calcID(4, 2, 4)]);
//		
		//action 5...
		//CommandeBrutAuto.addObject ("action 5 @ bascule gauche balance gauche @ Pos 1", 
		//                            m_autonomousCommandArray[calcID(1, 0, 5)]); 
		
		
		SmartDashboard.putData("Selection Autonomes", CommandeBrutAuto);
	}*/

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    @Override
    public void disabledInit(){

    }

    @Override
    public void disabledPeriodic() {
        Scheduler.getInstance().run();
       // driveTrain.reset();
       // driveTrain.getAhrs().reset();
    }

    @Override
    public void autonomousInit() {
    	// driveTrain.reset();
        driveTrain.getAhrs().reset();
       
        gameCode = ds.getGameSpecificMessage();
    	//if (gameCode.charAt(0) == 'L') // Bascule cote gauche
        if (gameCode.charAt(0) == 'L')
		{
			//m_autonomousCommand = m_autoChooserLeft.getSelected();
			m_autonomousCommand = new TwoCubeEasy(FROM_RIGHT_PORTAL.SCALE_RIGHT_TRAVEL, FROM_RIGHT_PORTAL.SCALE_RIGHT_FINISH, FROM_RIGHT_PORTAL.SCALE_RIGHT_FINISH, -90, 0.60, 0.50);
			//m_autonomousCommand = new RunPathTheory6(FROM_RIGHT.START_POINT,FROM_RIGHT.CONTROL_POINT_ONE,FROM_RIGHT.CONTROL_POINT_TWO,FROM_RIGHT.END_POINT,8,0.8, false);
        	//  m_autonomousCommand = new Theory6BasicCommandGroup();
        	if (m_autonomousCommand != null) {
	    		m_autonomousCommand.start();
	    	}
		}
        else if (gameCode.charAt(0) == 'R')
        //else if (tempGameData.charAt(0) == 'R') // Bascule cote droit
		{
    		m_autonomousCommand = m_autoChooserRight.getSelected();
	    	if (m_autonomousCommand != null) {
	    		m_autonomousCommand.start();
	    	}
		}
		else {  // Sinon equivalent de l'autoline
    	    //autonomousCommand = new DriveDistanceCommand(135,1);
			m_autonomousCommand = new PosXColorXObjAutolineCommand();
			if (m_autonomousCommand != null) {
				m_autonomousCommand.start();
			}
		}
		
	    //chooseAutonomous();
    }

	/*private void chooseAutonomous() {
		//
		// Retrieve selected choices for the autonomous command
   	  //  Command CommandeBrutAutoCommand = (Command)CommandeBrutAuto.getSelected();
		//int PositionRobotAutoIndex      = (Integer)PositionRobotAuto.getSelected();
		int ActionAutonomeIndex         = (Integer)ActionAutonome.getSelected();
		
		String tempGameData = DriverStation.getInstance().getGameSpecificMessage();
		int CoteBasculeAuto = 0;  // Default 0 = 'L'
		if (tempGameData.charAt(0) == 'R')
		{
			CoteBasculeAuto = 1;
		}
		//
		int CoteBalanceAuto = 0;  // Default 0 = 'L'
		if (tempGameData.charAt(1) == 'R')
		{
			CoteBalanceAuto = 2;
		}
		int configurationCotes = CoteBasculeAuto + CoteBalanceAuto;
		
		//
		// Selecting desired autonomous command
		//
        if (PositionRobotAutoIndex != 0) // Pas ManualOveride...
		{
   		    // Combine values to retrieve Command id
			int commandIndex = PositionRobotAutoIndex + ActionAutonomeIndex + configurationCotes;
			System.out.println("Combining posindex= "+ PositionRobotAutoIndex + 
					           " + obj= " + ActionAutonomeIndex + " + cotes= " + configurationCotes + 
					           " into " + commandIndex);
			
			m_autonomousCommand = m_autonomousCommandArray[commandIndex];
		}
		else if (PositionRobotAutoIndex == 0 && CommandeBrutAutoCommand != null ) 
		{
			m_autonomousCommand = CommandeBrutAutoCommand;
		}
		else 
		{
			System.out.println("An impossible error occurred at the Autonomous Command Choosing step (How did you?!?)");
			System.out.println("Setting autonomousCommand null");
			System.out.println("But really, please find the impossible error and fix it!");
			System.out.println("This error means that CommandeBrutAutoCommand or ActionAutonomeIndex is equals to null");
			System.out.println("This error is in Robot.java");
			System.out.println("Hopes that help fixing the _impossible_ error... ~Nathan");
			//System.out.println("And yes, I have too much time on my hand");
		}
		
		//
		//
		//
		if (m_autonomousCommand != null)
		{
			System.out.println("Starting Action");
			//m_autonomousCommand.start();
		}
		else
		{
		    System.out.println("Not an existing action");
		}
	}*/

    /**
     * This function is called periodically during autonomous
     */
    @Override
    public void autonomousPeriodic() {
    	System.out.println("AutonomousPeriodic");
    	SmartDashboard.putNumber ("RobotAngle3", driveTrain.getAhrs().getYaw());
        Scheduler.getInstance().run();
    }

    @Override
    public void teleopInit() {
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (m_autonomousCommand != null) m_autonomousCommand.cancel();
        driveTrain.resetEncoders();
        driveTrain.getAhrs().reset();
        cameras.drivingMode();//added after Finger Lakes
    }

    /**
     * This function is called periodically during operator control
     */
	@Override
	public void teleopPeriodic() {
		Scheduler.getInstance().run();
		log();
	}
	
	//
	//  HELPER FUNCTIONS
	//
	
	private void log() {
		SmartDashboard.putNumber ("Left Distance", driveTrain.getLeftEncoderDistance());
		SmartDashboard.putNumber ("Right Distance", driveTrain.getRightEncoderDistance());
		//SmartDashboard.putNumber ("LeftEncoder Rate",  driveTrain.getLeftRate());
		//SmartDashboard.putNumber ("RightEncoder Rate", driveTrain.getRightRate());
		SmartDashboard.putBoolean("DetectCube", Robot.pinceSubsystem.IsCubeHere());
		SmartDashboard.putBoolean("PhotoSwitchCube", RobotMap.PhotoSwitchCube.get());
		SmartDashboard.putBoolean("PetitCadreUp", Robot.PetitCadreSubsystem.PetitCadreIsUp());
		SmartDashboard.putBoolean("PetitCadreDown", Robot.PetitCadreSubsystem.PetitCadreIsDown());
		SmartDashboard.putBoolean("GrandCadreUp", Robot.GrandCadreSubsystem.GrandCadreIsUp());
		SmartDashboard.putBoolean("GrandCadreDown", Robot.GrandCadreSubsystem.GrandCadreIsDown());
	    SmartDashboard.putNumber ("ZAxis",Robot.oi.getPilotStick().getZ());
		//SmartDashboard.putBoolean("IMU_Connected", RobotMap.ahrs.isConnected());
       // SmartDashboard.putBoolean("IMU_IsCalibrating", RobotMap.ahrs.isCalibrating());
      //  SmartDashboard.putNumber ("IMU_Yaw", RobotMap.ahrs.getYaw());
       // SmartDashboard.putNumber ("IMU_Pitch", RobotMap.ahrs.getPitch());
        SmartDashboard.putNumber ("TeleoPAngleGet", driveTrain.getAhrs().getAngle());
        SmartDashboard.putNumber ("TeleoPAngleYaw", driveTrain.getAhrs().getYaw());
	}
	
	/*public int calcID(int position, int colorConfig, int objective)
	{
		return (position * AUTOCHOOSER_POSITION_ENCODER) + (colorConfig * AUTOCHOOSER_COLORPOSITION_ENCODER) + (objective * AUTOCHOOSER_OBJECTIVE_ENCODER);
	}
	
	public void autonomousCommandArrayInit() //this is where the m_autonomousCommandArray gets its values, it is CRUCIAL to update it well
	{
		m_autonomousCommandArray[calcID(0, 0, 1)] = new NeRienFaireCommand();
		
		//
		// IN SAME ORDER AS IN THE EXCEL STRATEGIC PLAN
		//
		





		m_autonomousCommandArray[calcID(1, 0, 1)] = new PosXColorXObjAutolineCommand();
		m_autonomousCommandArray[calcID(1, 2, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		//
		//m_autonomousCommandArray[calcID(2, 0, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)]; // Not used
		//m_autonomousCommandArray[calcID(2, 2, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)]; // Not used
		//
		m_autonomousCommandArray[calcID(3, 0, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		m_autonomousCommandArray[calcID(3, 2, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		//
		m_autonomousCommandArray[calcID(4, 0, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		m_autonomousCommandArray[calcID(4, 2, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		//
		m_autonomousCommandArray[calcID(1, 1, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		m_autonomousCommandArray[calcID(1, 3, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		//
		//m_autonomousCommandArray[calcID(2, 1, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)]; // Not used
		//m_autonomousCommandArray[calcID(2, 3, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)]; // Not used
		//
		m_autonomousCommandArray[calcID(3, 1, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		m_autonomousCommandArray[calcID(3, 3, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		//
		m_autonomousCommandArray[calcID(4, 1, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		m_autonomousCommandArray[calcID(4, 3, 1)] = m_autonomousCommandArray[calcID(1, 0, 1)];
		//
		//
		m_autonomousCommandArray[calcID(1, 0, 2)] = new Pos1ColorLeftObjCubeBasculeCommand();
		m_autonomousCommandArray[calcID(1, 2, 2)] = m_autonomousCommandArray[calcID(1, 0, 2)];
		//
		m_autonomousCommandArray[calcID(2, 0, 2)] = new Pos2ColorLeftObjCubeBascule1Command();
		m_autonomousCommandArray[calcID(2, 2, 2)] = m_autonomousCommandArray[calcID(2, 0, 2)];
		m_autonomousCommandArray[calcID(2, 0, 3)] = new Pos2ColorLeftObjCubeBascule2Command();
		m_autonomousCommandArray[calcID(2, 2, 3)] = m_autonomousCommandArray[calcID(2, 0, 3)];
		//
		m_autonomousCommandArray[calcID(3, 0, 2)] = new Pos3ColorLeftObjCubeBasculeCommand();
		m_autonomousCommandArray[calcID(3, 2, 2)] = m_autonomousCommandArray[calcID(3, 0, 2)];
		//
		m_autonomousCommandArray[calcID(4, 0, 2)] = new Pos4ColorLeftObjCubeBasculeCommand();
		m_autonomousCommandArray[calcID(4, 2, 2)] = m_autonomousCommandArray[calcID(4, 0, 2)];
		//
		m_autonomousCommandArray[calcID(1, 1, 2)] = new Pos1ColorRightObjCubeBasculeCommand();
		m_autonomousCommandArray[calcID(1, 3, 2)] = m_autonomousCommandArray[calcID(1, 1, 2)];
		//
		m_autonomousCommandArray[calcID(2, 1, 2)] = new Pos2ColorRightObjCubeBascule1Command();
		m_autonomousCommandArray[calcID(2, 3, 2)] = m_autonomousCommandArray[calcID(2, 1, 2)];
		m_autonomousCommandArray[calcID(2, 1, 3)] = new Pos2ColorRightObjCubeBascule2Command();
		m_autonomousCommandArray[calcID(2, 3, 3)] = m_autonomousCommandArray[calcID(2, 1, 3)];
		//
		m_autonomousCommandArray[calcID(3, 1, 2)] = new Pos3ColorRightObjCubeBasculeCommand();
		m_autonomousCommandArray[calcID(3, 3, 2)] = m_autonomousCommandArray[calcID(3, 1, 2)];
		//
		m_autonomousCommandArray[calcID(4, 1, 2)] = new Pos4ColorRightObjCubeBasculeCommand();
		m_autonomousCommandArray[calcID(4, 3, 2)] = m_autonomousCommandArray[calcID(4, 1, 2)];
		//
		//
		m_autonomousCommandArray[calcID(1, 0, 4)] = new Pos1ColorLeftObjCubeBalanceCommand();
		m_autonomousCommandArray[calcID(1, 1, 4)] = m_autonomousCommandArray[calcID(1, 0, 4)];
		//
		//m_autonomousCommandArray[calcID(2, 0, 4)] = new DummyCommand(2);                     // Not used
		//m_autonomousCommandArray[calcID(2, 1, 4)] = m_autonomousCommandArray[calcID(2, 0, 4)]; // Not used
		//
		//m_autonomousCommandArray[calcID(3, 0, 4)] = new DummyCommand(3);                     // Not used
		//m_autonomousCommandArray[calcID(3, 1, 4)] = m_autonomousCommandArray[calcID(3, 0, 4)]; // Not used
		//
		m_autonomousCommandArray[calcID(4, 0, 4)] = new Pos4ColorLeftObjCubeBalanceCommand();
		m_autonomousCommandArray[calcID(4, 1, 4)] = m_autonomousCommandArray[calcID(4, 0, 4)];
		//
		m_autonomousCommandArray[calcID(1, 2, 4)] = new Pos1ColorRightObjCubeBalanceCommand();
		m_autonomousCommandArray[calcID(1, 3, 4)] = m_autonomousCommandArray[calcID(1, 2, 4)];
		//
		//m_autonomousCommandArray[calcID(2, 2, 4)] = new DummyCommand(2);                     // Not used
		//m_autonomousCommandArray[calcID(2, 3, 4)] = m_autonomousCommandArray[calcID(2, 2, 4)]; // Not used
		//
		//m_autonomousCommandArray[calcID(3, 2, 4)] = new DummyCommand(3);                     // Not used
		//m_autonomousCommandArray[calcID(3, 3, 4)] = m_autonomousCommandArray[calcID(3, 2, 4)]; // Not used
		//
		m_autonomousCommandArray[calcID(4, 2, 4)] = new Pos4ColorRightObjCubeBalanceCommand();
		m_autonomousCommandArray[calcID(4, 3, 4)] = m_autonomousCommandArray[calcID(4, 2, 4)];
	}*/
}